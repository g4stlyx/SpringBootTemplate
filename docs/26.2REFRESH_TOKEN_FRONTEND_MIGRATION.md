# Ref Token Implementation - Frontend & Mobile Migration Guide

## Overview

The backend now uses a **hybrid refresh + access token** system:
- **Access Token**: Short-lived JWT (15 minutes), used for API authorization
- **Refresh Token**: Long-lived opaque token (30 days), used to get new access tokens
- **Token Rotation**: Every refresh returns a NEW refresh token (old one is revoked)
- **Reuse Detection**: If a revoked refresh token is reused, ALL user tokens are revoked (security measure)

---

## Response Changes

### Login/Register Response

```json
{
  "success": true,
  "message": "Login successful",
  "token": "eyJhbGciOiJIUzI1Ni...",
  "user": {
    "id": 1,
    "username": "testuser",
    "email": "test@example.com",
    "userType": "client"
  }
}
```

**Important Notes**:
- `token` field contains the access token (JWT, 15 min lifetime)
- Refresh token is set as HttpOnly cookie (web) or needs to be managed manually (mobile)
- Cookie name: `refreshToken` (configurable)

### Refresh Response

```json
{
  "accessToken": "eyJhbGciOiJIUzI1Ni...",
  "tokenType": "Bearer",
  "expiresIn": 900,
  "refreshToken": "660e8400-e29b-41d4-a716-446655440001"
}
```

**Note**: `refreshToken` field only included for mobile clients

---

## Web Frontend (React/Next.js/Vue) Integration

### 1. Configure API Client with Credentials

```typescript
// axios configuration
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:8080',
  withCredentials: true, // CRITICAL: Enables cookie support
  headers: {
    'Content-Type': 'application/json',
  },
});

export default api;
```

```typescript
// fetch configuration
const API_URL = 'http://localhost:8080';

const fetchWithCredentials = (url: string, options: RequestInit = {}) => {
  return fetch(url, {
    ...options,
    credentials: 'include', // CRITICAL: Enables cookie support
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });
};
```

---

### 2. Login Handler (Web)

```typescript
// Before
const login = async (credentials: LoginRequest) => {
  const response = await api.post('/api/v1/auth/login', credentials);
  const { token } = response.data;
  
  // Store access token
  localStorage.setItem('accessToken', token);
  
  return response.data;
};

// After
const login = async (credentials: LoginRequest) => {
  const response = await api.post('/api/v1/auth/login', credentials);
  const { token } = response.data;
  
  // Store access token
  localStorage.setItem('accessToken', token);
  
  // Refresh token automatically stored in HttpOnly cookie by browser
  // No manual handling needed!
  
  return response.data;
};
```

---

### 3. Axios Interceptor with Auto-Refresh

```typescript
import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:8080',
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Queue for failed requests during token refresh
let isRefreshing = false;
let failedQueue: Array<{
  resolve: (value: unknown) => void;
  reject: (reason?: any) => void;
}> = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });

  failedQueue = [];
};

// Request interceptor: Add access token to requests
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor: Handle 401 and refresh token
api.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config as AxiosRequestConfig & { _retry?: boolean };

    // If error is 401 and we haven't retried yet
    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        // Queue this request until refresh completes
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        })
          .then((token) => {
            if (originalRequest.headers) {
              originalRequest.headers.Authorization = `Bearer ${token}`;
            }
            return api(originalRequest);
          })
          .catch((err) => Promise.reject(err));
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        // Call refresh endpoint (refresh token sent via cookie automatically)
        const response = await api.post('/api/v1/auth/refresh', {});
        const { accessToken } = response.data;

        // Store new access token
        localStorage.setItem('accessToken', accessToken);

        // Update Authorization header
        if (originalRequest.headers) {
          originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        }

        // Process queued requests
        processQueue(null, accessToken);

        // Retry original request
        return api(originalRequest);
      } catch (refreshError) {
        // Refresh failed - logout user
        processQueue(refreshError, null);
        localStorage.removeItem('accessToken');
        
        // Redirect to login
        window.location.href = '/login';
        
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);

export default api;
```

---

### 4. Fetch Interceptor with Auto-Refresh

```typescript
const API_URL = 'http://localhost:8080';

let isRefreshing = false;
let failedQueue: Array<{
  resolve: (value: unknown) => void;
  reject: (reason?: any) => void;
}> = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

export const apiFetch = async (url: string, options: RequestInit = {}) => {
  // Add access token to request
  const token = localStorage.getItem('accessToken');
  const headers = {
    'Content-Type': 'application/json',
    ...(token && { Authorization: `Bearer ${token}` }),
    ...options.headers,
  };

  let response = await fetch(`${API_URL}${url}`, {
    ...options,
    credentials: 'include',
    headers,
  });

  // Handle 401 (expired access token)
  if (response.status === 401 && !options.headers?.['X-Retry']) {
    if (isRefreshing) {
      // Queue this request
      return new Promise((resolve, reject) => {
        failedQueue.push({ resolve, reject });
      }).then((newToken) => {
        // Retry with new token
        return apiFetch(url, {
          ...options,
          headers: {
            ...options.headers,
            Authorization: `Bearer ${newToken}`,
            'X-Retry': 'true',
          },
        });
      });
    }

    isRefreshing = true;

    try {
      // Refresh access token
      const refreshResponse = await fetch(`${API_URL}/api/v1/auth/refresh`, {
        method: 'POST',
        credentials: 'include',
        headers: { 'Content-Type': 'application/json' },
      });

      if (!refreshResponse.ok) {
        throw new Error('Refresh failed');
      }

      const data = await refreshResponse.json();
      const { accessToken } = data;

      // Store new token
      localStorage.setItem('accessToken', accessToken);

      // Process queued requests
      processQueue(null, accessToken);

      // Retry original request
      return apiFetch(url, {
        ...options,
        headers: {
          ...options.headers,
          Authorization: `Bearer ${accessToken}`,
          'X-Retry': 'true',
        },
      });
    } catch (error) {
      // Refresh failed - logout
      processQueue(error, null);
      localStorage.removeItem('accessToken');
      window.location.href = '/login';
      throw error;
    } finally {
      isRefreshing = false;
    }
  }

  return response;
};
```

---

### 5. Logout Handler (Web)

```typescript
const logout = async () => {
  try {
    // Call logout endpoint (revokes refresh token)
    await api.post('/api/v1/auth/logout');
  } catch (error) {
    console.error('Logout error:', error);
  } finally {
    // Clear local storage
    localStorage.removeItem('accessToken');
    
    // Redirect to login
    window.location.href = '/login';
  }
};
```

---

### 6. Logout from All Devices

```typescript
const logoutAll = async () => {
  try {
    // Requires authentication (access token)
    await api.post('/api/v1/auth/logout-all');
  } catch (error) {
    console.error('Logout all error:', error);
  } finally {
    // Clear local storage
    localStorage.removeItem('accessToken');
    
    // Redirect to login
    window.location.href = '/login';
  }
};
```

---

## Mobile App (Flutter/React Native) Integration

### Key Differences from Web

1. **No automatic cookie handling** - must manage refresh token manually
2. **Store tokens securely** - use encrypted storage (Flutter Secure Storage / Keychain)
3. **Include refresh token in request body** when calling refresh endpoint

---

### 1. Flutter Implementation

#### Storage Helper

```dart
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class TokenStorage {
  static const _storage = FlutterSecureStorage();
  
  static const _accessTokenKey = 'accessToken';
  static const _refreshTokenKey = 'refreshToken';
  
  static Future<void> saveTokens({
    required String accessToken,
    required String refreshToken,
  }) async {
    await Future.wait([
      _storage.write(key: _accessTokenKey, value: accessToken),
      _storage.write(key: _refreshTokenKey, value: refreshToken),
    ]);
  }
  
  static Future<String?> getAccessToken() async {
    return await _storage.read(key: _accessTokenKey);
  }
  
  static Future<String?> getRefreshToken() async {
    return await _storage.read(key: _refreshTokenKey);
  }
  
  static Future<void> clearTokens() async {
    await Future.wait([
      _storage.delete(key: _accessTokenKey),
      _storage.delete(key: _refreshTokenKey),
    ]);
  }
}
```

#### API Client with Auto-Refresh

```dart
import 'package:dio/dio.dart';
import 'token_storage.dart';

class ApiClient {
  static const baseUrl = 'http://your-api.com';
  final Dio _dio = Dio(BaseOptions(baseUrl: baseUrl));
  
  bool _isRefreshing = false;
  final List<void Function(String)> _refreshCallbacks = [];
  
  ApiClient() {
    _setupInterceptors();
  }
  
  void _setupInterceptors() {
    // Request interceptor: Add access token
    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) async {
        final token = await TokenStorage.getAccessToken();
        if (token != null) {
          options.headers['Authorization'] = 'Bearer $token';
        }
        handler.next(options);
      },
      onError: (error, handler) async {
        if (error.response?.statusCode == 401) {
          // Token expired, try to refresh
          try {
            final newToken = await _refreshAccessToken();
            
            // Retry original request with new token
            final options = error.requestOptions;
            options.headers['Authorization'] = 'Bearer $newToken';
            
            final response = await _dio.fetch(options);
            handler.resolve(response);
          } catch (e) {
            // Refresh failed, logout
            await TokenStorage.clearTokens();
            // Navigate to login screen
            handler.reject(error);
          }
        } else {
          handler.next(error);
        }
      },
    ));
  }
  
  Future<String> _refreshAccessToken() async {
    if (_isRefreshing) {
      // Wait for ongoing refresh
      return await Future.delayed(
        Duration(milliseconds: 100),
        () => _refreshAccessToken(),
      );
    }
    
    _isRefreshing = true;
    
    try {
      final refreshToken = await TokenStorage.getRefreshToken();
      if (refreshToken == null) {
        throw Exception('No refresh token');
      }
      
      // Call refresh endpoint
      final response = await Dio().post(
        '$baseUrl/api/v1/auth/refresh',
        data: {'refreshToken': refreshToken},
      );
      
      final newAccessToken = response.data['accessToken'];
      final newRefreshToken = response.data['refreshToken'];
      
      // Save new tokens
      await TokenStorage.saveTokens(
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
      );
      
      // Notify waiting requests
      for (var callback in _refreshCallbacks) {
        callback(newAccessToken);
      }
      _refreshCallbacks.clear();
      
      return newAccessToken;
    } finally {
      _isRefreshing = false;
    }
  }
  
  Future<Response> post(String path, {Map<String, dynamic>? data}) {
    return _dio.post(path, data: data);
  }
  
  Future<Response> get(String path) {
    return _dio.get(path);
  }
}
```

#### Login Handler (Flutter)

```dart
Future<void> login(String username, String password, String userType) async {
  try {
    final response = await apiClient.post('/api/v1/auth/login', data: {
      'username': username,
      'password': password,
      'userType': userType,
    });
    
    final accessToken = response.data['token'];
    // For mobile, you need to extract refresh token from response or Set-Cookie header
    // If the backend sends refresh token in body for mobile clients:
    final refreshToken = response.data['refreshToken'] ?? 
                        _extractRefreshTokenFromCookie(response);
    
    // Store tokens securely
    await TokenStorage.saveTokens(
      accessToken: accessToken,
      refreshToken: refreshToken!,
    );
    
    // Navigate to home screen
  } catch (e) {
    print('Login error: $e');
  }
}

String? _extractRefreshTokenFromCookie(Response response) {
  final cookies = response.headers['set-cookie'];
  if (cookies == null) return null;
  
  for (var cookie in cookies) {
    if (cookie.startsWith('refreshToken=')) {
      return cookie.split(';')[0].split('=')[1];
    }
  }
  return null;
}
```

#### Logout Handler (Flutter)

```dart
Future<void> logout() async {
  try {
    final refreshToken = await TokenStorage.getRefreshToken();
    
    // Call logout endpoint
    await apiClient.post('/api/v1/auth/logout', data: {
      'refreshToken': refreshToken,
    });
  } catch (e) {
    print('Logout error: $e');
  } finally {
    // Clear tokens
    await TokenStorage.clearTokens();
    
    // Navigate to login screen
  }
}
```

---

### 2. React Native Implementation

#### Storage Helper

```typescript
import * as SecureStore from 'expo-secure-store';

export const TokenStorage = {
  async saveTokens(accessToken: string, refreshToken: string) {
    await Promise.all([
      SecureStore.setItemAsync('accessToken', accessToken),
      SecureStore.setItemAsync('refreshToken', refreshToken),
    ]);
  },

  async getAccessToken() {
    return await SecureStore.getItemAsync('accessToken');
  },

  async getRefreshToken() {
    return await SecureStore.getItemAsync('refreshToken');
  },

  async clearTokens() {
    await Promise.all([
      SecureStore.deleteItemAsync('accessToken'),
      SecureStore.deleteItemAsync('refreshToken'),
    ]);
  },
};
```

#### API Client with Auto-Refresh

```typescript
import axios, { AxiosError, AxiosRequestConfig } from 'axios';
import { TokenStorage } from './TokenStorage';

const api = axios.create({
  baseURL: 'http://your-api.com',
  headers: {
    'Content-Type': 'application/json',
  },
});

let isRefreshing = false;
let failedQueue: Array<{
  resolve: (value: unknown) => void;
  reject: (reason?: any) => void;
}> = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

// Request interceptor: Add access token
api.interceptors.request.use(
  async (config) => {
    const token = await TokenStorage.getAccessToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor: Handle 401 and refresh
api.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config as AxiosRequestConfig & { _retry?: boolean };

    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        }).then((token) => {
          if (originalRequest.headers) {
            originalRequest.headers.Authorization = `Bearer ${token}`;
          }
          return api(originalRequest);
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        const refreshToken = await TokenStorage.getRefreshToken();
        if (!refreshToken) {
          throw new Error('No refresh token');
        }

        // Call refresh endpoint with refresh token in body
        const response = await api.post('/api/v1/auth/refresh', {
          refreshToken,
        });

        const { accessToken, refreshToken: newRefreshToken } = response.data;

        // Save new tokens
        await TokenStorage.saveTokens(accessToken, newRefreshToken);

        // Update request header
        if (originalRequest.headers) {
          originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        }

        processQueue(null, accessToken);

        return api(originalRequest);
      } catch (refreshError) {
        processQueue(refreshError, null);
        await TokenStorage.clearTokens();
        
        // Navigate to login screen
        // navigation.navigate('Login');
        
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);

export default api;
```

#### Login Handler (React Native)

```typescript
export const login = async (
  username: string,
  password: string,
  userType: string
) => {
  try {
    const response = await api.post('/api/v1/auth/login', {
      username,
      password,
      userType,
    });

    const { token: accessToken } = response.data;
    
    // For mobile, extract refresh token from response
    // Option 1: If backend sends it in response body
    const refreshToken = response.data.refreshToken;
    
    // Option 2: Extract from Set-Cookie header
    // const refreshToken = extractRefreshTokenFromCookie(response);

    await TokenStorage.saveTokens(accessToken, refreshToken);

    return response.data;
  } catch (error) {
    console.error('Login error:', error);
    throw error;
  }
};
```

#### Logout Handler (React Native)

```typescript
export const logout = async () => {
  try {
    const refreshToken = await TokenStorage.getRefreshToken();
    
    // Call logout endpoint
    await api.post('/api/v1/auth/logout', {
      refreshToken,
    });
  } catch (error) {
    console.error('Logout error:', error);
  } finally {
    await TokenStorage.clearTokens();
    
    // Navigate to login
    // navigation.navigate('Login');
  }
};
```

---

## CORS Configuration

Ensure your backend CORS config allows credentials:

```java
@Configuration
public class CorsConfig {
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                    .allowedOrigins(
                        "http://localhost:3000",
                        "https://yourdomain.com"
                    )
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                    .allowedHeaders("*")
                    .allowCredentials(true) // IMPORTANT for cookies
                    .maxAge(3600);
            }
        };
    }
}
```

---

## Testing Checklist

### Web App
- [ ] Login stores access token and receives refresh token cookie
- [ ] API calls include `Authorization: Bearer <token>` header
- [ ] API calls include `credentials: 'include'`
- [ ] 401 errors trigger automatic refresh
- [ ] After refresh, original request retries automatically
- [ ] Logout clears tokens and redirects to login
- [ ] Multiple simultaneous 401s are queued during refresh

### Mobile App
- [ ] Login stores both tokens in secure storage
- [ ] API calls include `Authorization: Bearer <token>` header
- [ ] Refresh endpoint includes refresh token in request body
- [ ] 401 errors trigger automatic refresh
- [ ] After refresh, original request retries automatically
- [ ] Logout clears tokens from secure storage
- [ ] Tokens persist across app restarts

---

## Security Best Practices

1. **Web**: Always use HTTPS in production (set `Secure` flag on cookies)
2. **Mobile**: Store tokens in secure storage (Keychain/Keystore)
3. **Never log tokens** in production
4. **Clear tokens on logout** from all storage locations
5. **Handle token refresh failures** gracefully (redirect to login)
6. **Implement proper error handling** for network failures
7. **Use HTTPS** for all API calls
8. **Validate token expiry** before making requests (optional optimization)

---

## Troubleshooting

### Web: "Refresh token not received"
- Check CORS allows credentials
- Verify `credentials: 'include'` in fetch/axios
- Check cookie domain matches frontend domain

### Mobile: "Refresh failed"
- Verify refresh token is stored correctly
- Check refresh token is included in request body
- Ensure token hasn't expired (30 days)

### All: "Multiple refresh attempts"
- Implement request queuing during refresh
- Use `isRefreshing` flag to prevent concurrent refreshes

---

## Next Steps

1. Update login/register endpoints to set refresh token cookies
2. Implement auto-refresh interceptors
3. Test token rotation workflow
4. Test logout functionality
5. Test "logout all devices" functionality
6. Monitor token usage via admin endpoints

---

## Related Documentation

- Backend Implementation: [26.1REFRESH_TOKEN_IMPLEMENTATION_PLAN.md](26.1REFRESH_TOKEN_IMPLEMENTATION_PLAN.md)
- API Documentation: See main implementation plan
- Postman Collections: `postman_files/26_refresh_token.postman_collection.json`
